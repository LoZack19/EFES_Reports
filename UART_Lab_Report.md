# UART Lab Report

The **goal** of the UART Software laboratory was to design a driver which implments the UART protocol to handle UART communication through GPIO pins.

## Project 1 - Environment Configuration

The **goal** of this project was to write a working hello world project in C running on the Nios II processor by using the `printf()` function, in order to check wether the environment worked correctly before starting to work on the actual assignments.

The first step was to flash the Nios II processor generated with Platform Designer onto the Altera DE1-SoC board.

The second step was to create a new project with the _Nios II Software Build Tools for Eclipse_ from the Board Support Package (BSP) template generated by Platform Designer.

The third step was to configure the Board Support Package (BSP) correctly through the BSP editor, as detailed by the lab instructions.

- `stdout` set to `jtag_uart_0`
- `sys_clk_timer` set to `none`
- `timestamp_timer` set to `timer_0`

After this, it was possible to generate the BSP.

We built the whole project with the following `main()` function.

```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
}
```

## Project 2 - Experimenting with GPIO pins

The **goal** of this project was simply to periodically complement the logic value on a pin on the right header connector and display the result on the oscilloscope. 
 
We wrote the following program to accomplish this task:  
 
```c 
#include <stdio.h>
#include <stdint.h>
#include "system.h"
#include "sys/alt_timestamp.h"
#include "altera_avalon_pio_regs.h"
 
void wait_us(uint32_t time_us) {
    uint32_t tps = alt_timestamp_freq();
    uint32_t nticks = tps / 1000000 * time_us;
 
    alt_timestamp_start();
    while(alt_timestamp() < nticks);
}
 
int main()
{
    int val = 1;
    while(1) {
        wait_us(1000);
        IOWR_ALTERA_AVALON_PIO_DATA(NIOS_HEADER_CONN_BASE, val);
        val ^= 1;
    }

    return 0;
}
```

The function `wait_us` starts the timestamp counter and busy waits until the required number of ticks have passed. 
 
The `main` function is simply an infinite loop that waits for one second and flips the value of the first pin of the header connector with a logical xor. As shown in the picture below, we managed to measure the waveform generated by such an operation: 

By connecting the oscilloscope probe to pin 1 of GPIO1 and GND we could see the voltage toggling with the expected period of $2000 ms$

![GPIO1(0) toggling](pics/lab2_proj2_oscilloscope.png)

## Project 3 
For project 3, we connected our computer with a USB mini type B connector to the DE1-SoC board, and we used PuTTY with the following parameters:

- Baud Rate: 300 
- Bits per character: 8 
- Parity: none 
- Number of stop bits: 1 
- Flow Control: None 

We also connected pin 2 of the left header connector to an oscilloscope (and used pin 5 of the VGA connector of the board as ground), which was then set to trigger on the falling edge of the signal. After connecting PuTTY to the appropriate COM port, we tried sending, among other characters, the character `0x55` (i.e. `0b01010101`), whose waveform can be seen below: 
 
![Input 0x55 to UART](pics\lab2_proj3_input0x55.png)

It can be seen that the start character (0) is followed by the LSB of the character (1). The MSB of the character (0) is followed by an end character (1), after which the line returns to an idle state.
 
## Project 4 - Implementing UART receiver in software

The **goal** of this project was to implement a software version of UART. With a similar setup to that of project 3, we flashed the following program into the SoC: 
 
```c 
#include <stdint.h>
#include <stdio.h>

#include "altera_avalon_pio_regs.h"
#include "sys/alt_timestamp.h"
#include "system.h"

// Wait for `time_us` microseconds
void wait_us(uint32_t time_us) {
    uint32_t tps = alt_timestamp_freq();
    uint32_t nticks = tps / 1000000 * time_us;

    alt_timestamp_start();
    while (alt_timestamp() < nticks);
}

// Read GPIO1 pin 1
__attribute__((always_inline)) static inline uint8_t gpio_read() {
    return (uint8_t)IORD_ALTERA_AVALON_PIO_DATA(NIOS_UARTRX_BASE) & 0x00000001;
}

int main() {
    const int BAUD_RATE = 1000;
    const int CHARACTER_SIZE = 8;
    const int STOP_BITS = 1;

    const uint8_t START_BIT = 0x00;
    const uint8_t STOP_SEQ = 0x01;

    int uart_period_us = 1000000 / BAUD_RATE;

    uint8_t fifo[0x100];
    uint8_t fifo_in = 0;
    uint8_t fifo_out = 0;

    int i;
    for (;;) {
        while (gpio_read() != 0);

        // Read character
        uint8_t reading = 0x00;
        for (i = 0; i < CHARACTER_SIZE; i++) {
            wait_us(uart_period_us);
            reading = (reading >> 1) | (gpio_read() << 7);
        }

        // No parity check

        // Read stop sequence
        uint8_t stop_seq = 0x00;
        for (i = 0; i < STOP_BITS; i++) {
            wait_us(uart_period_us);
            stop_seq = (stop_seq << 1) | gpio_read();
        }

        // Eventually log error through jtag interface
        if (stop_seq != STOP_SEQ) {
            puts("[ERROR] Protocol Error");
            break;
        }

        printf("Received %c\n", reading);
        fifo[fifo_in] = reading;
        fifo_in = fifo_in + 1;
    }

    for (;;);
}
``` 
The comments already outline what each part of the code does. It should be noted that we used a FIFO queue to store the read characters. In the end the FIFO was never used, but the entire message is stored there.

We provide the output of the program, which coincides to what we expected to see.

![Output of the program](C:\Users\s346305\Desktop\lab2_uart\pics\lab2_proj3_output.png)